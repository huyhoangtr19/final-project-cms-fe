import {
  BaseComponent,
  CalendarImpl,
  ContentContainer,
  EventImpl,
  NowTimer,
  Splitter,
  TableDateCell,
  TableDowCell,
  ViewContextType,
  _,
  addDays,
  combineEventUis,
  compareByFieldSpecs,
  computeFallbackHeaderFormat,
  config,
  createEventUi,
  createPlugin,
  filterHash,
  flexibleCompare,
  formatDayString,
  guid,
  identity,
  isPropsEqual,
  isPropsValid,
  isValidDate,
  mapHash,
  memoize,
  memoizeObjArg,
  mergeEventStores,
  parseBusinessHours,
  parseClassNames,
  parseFieldSpecs,
  rangesEqual,
  rangesIntersect,
  refineProps,
  requestJson,
  unpromisify,
  y
} from "./chunk-TYLXF2SG.js";

// node_modules/@fullcalendar/premium-common/index.js
var UPGRADE_WINDOW = 365 + 7;
var INVALID_LICENSE_URL = "https://fullcalendar.io/docs/schedulerLicenseKey#invalid";
var OUTDATED_LICENSE_URL = "https://fullcalendar.io/docs/schedulerLicenseKey#outdated";
var PRESET_LICENSE_KEYS = [
  "GPL-My-Project-Is-Open-Source",
  "CC-Attribution-NonCommercial-NoDerivatives"
];
var CSS = {
  position: "absolute",
  zIndex: 99999,
  bottom: "1px",
  left: "1px",
  background: "#eee",
  borderColor: "#ddd",
  borderStyle: "solid",
  borderWidth: "1px 1px 0 0",
  padding: "2px 4px",
  fontSize: "12px",
  borderTopRightRadius: "3px"
};
function buildLicenseWarning(context) {
  let key = context.options.schedulerLicenseKey;
  let currentUrl = typeof window !== "undefined" ? window.location.href : "";
  if (!isImmuneUrl(currentUrl)) {
    let status = processLicenseKey(key, context.pluginHooks.premiumReleaseDate);
    if (status !== "valid") {
      return y("div", { className: "fc-license-message", style: CSS }, status === "outdated" ? y(
        _,
        null,
        "Your license key is too old to work with this version. ",
        y("a", { href: OUTDATED_LICENSE_URL }, "More Info")
      ) : y(
        _,
        null,
        "Your license key is invalid. ",
        y("a", { href: INVALID_LICENSE_URL }, "More Info")
      ));
    }
  }
  return null;
}
function processLicenseKey(key, premiumReleaseDate) {
  if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {
    return "valid";
  }
  const parts = (key || "").match(/^(\d+)-fcs-(\d+)$/);
  if (parts && parts[1].length === 10) {
    const purchaseDate = new Date(parseInt(parts[2], 10) * 1e3);
    const releaseDate = config.mockSchedulerReleaseDate || premiumReleaseDate;
    if (isValidDate(releaseDate)) {
      const minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);
      if (minPurchaseDate < purchaseDate) {
        return "valid";
      }
      return "outdated";
    }
  }
  return "invalid";
}
function isImmuneUrl(url) {
  return /\w+:\/\/fullcalendar\.io\/|\/examples\/[\w-]+\.html$/.test(url);
}
var OPTION_REFINERS = {
  schedulerLicenseKey: String
};
var index = createPlugin({
  name: "@fullcalendar/premium-common",
  premiumReleaseDate: "2025-04-02",
  optionRefiners: OPTION_REFINERS,
  viewContainerAppends: [buildLicenseWarning]
});

// node_modules/@fullcalendar/resource/internal-common.js
var PRIVATE_ID_PREFIX = "_fc:";
var RESOURCE_REFINERS = {
  id: String,
  parentId: String,
  children: identity,
  title: String,
  businessHours: identity,
  extendedProps: identity,
  // event-ui
  eventEditable: Boolean,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventConstraint: identity,
  eventOverlap: Boolean,
  eventAllow: identity,
  eventClassNames: parseClassNames,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String
};
function parseResource(raw, parentId = "", store, context) {
  let { refined, extra } = refineProps(raw, RESOURCE_REFINERS);
  let resource = {
    id: refined.id || PRIVATE_ID_PREFIX + guid(),
    parentId: refined.parentId || parentId,
    title: refined.title || "",
    businessHours: refined.businessHours ? parseBusinessHours(refined.businessHours, context) : null,
    ui: createEventUi({
      editable: refined.eventEditable,
      startEditable: refined.eventStartEditable,
      durationEditable: refined.eventDurationEditable,
      constraint: refined.eventConstraint,
      overlap: refined.eventOverlap,
      allow: refined.eventAllow,
      classNames: refined.eventClassNames,
      backgroundColor: refined.eventBackgroundColor,
      borderColor: refined.eventBorderColor,
      textColor: refined.eventTextColor,
      color: refined.eventColor
    }, context),
    extendedProps: Object.assign(Object.assign({}, extra), refined.extendedProps)
  };
  Object.freeze(resource.ui.classNames);
  Object.freeze(resource.extendedProps);
  if (store[resource.id]) ;
  else {
    store[resource.id] = resource;
    if (refined.children) {
      for (let childInput of refined.children) {
        parseResource(childInput, resource.id, store, context);
      }
    }
  }
  return resource;
}
function getPublicId(id) {
  if (id.indexOf(PRIVATE_ID_PREFIX) === 0) {
    return "";
  }
  return id;
}
var ResourceApi = class _ResourceApi {
  constructor(_context, _resource) {
    this._context = _context;
    this._resource = _resource;
  }
  setProp(name, value) {
    let oldResource = this._resource;
    this._context.dispatch({
      type: "SET_RESOURCE_PROP",
      resourceId: oldResource.id,
      propName: name,
      propValue: value
    });
    this.sync(oldResource);
  }
  setExtendedProp(name, value) {
    let oldResource = this._resource;
    this._context.dispatch({
      type: "SET_RESOURCE_EXTENDED_PROP",
      resourceId: oldResource.id,
      propName: name,
      propValue: value
    });
    this.sync(oldResource);
  }
  sync(oldResource) {
    let context = this._context;
    let resourceId = oldResource.id;
    this._resource = context.getCurrentData().resourceStore[resourceId];
    context.emitter.trigger("resourceChange", {
      oldResource: new _ResourceApi(context, oldResource),
      resource: this,
      revert() {
        context.dispatch({
          type: "ADD_RESOURCE",
          resourceHash: {
            [resourceId]: oldResource
          }
        });
      }
    });
  }
  remove() {
    let context = this._context;
    let internalResource = this._resource;
    let resourceId = internalResource.id;
    context.dispatch({
      type: "REMOVE_RESOURCE",
      resourceId
    });
    context.emitter.trigger("resourceRemove", {
      resource: this,
      revert() {
        context.dispatch({
          type: "ADD_RESOURCE",
          resourceHash: {
            [resourceId]: internalResource
          }
        });
      }
    });
  }
  getParent() {
    let context = this._context;
    let parentId = this._resource.parentId;
    if (parentId) {
      return new _ResourceApi(context, context.getCurrentData().resourceStore[parentId]);
    }
    return null;
  }
  getChildren() {
    let thisResourceId = this._resource.id;
    let context = this._context;
    let { resourceStore } = context.getCurrentData();
    let childApis = [];
    for (let resourceId in resourceStore) {
      if (resourceStore[resourceId].parentId === thisResourceId) {
        childApis.push(new _ResourceApi(context, resourceStore[resourceId]));
      }
    }
    return childApis;
  }
  /*
  this is really inefficient!
  TODO: make EventApi::resourceIds a hash or keep an index in the Calendar's state
  */
  getEvents() {
    let thisResourceId = this._resource.id;
    let context = this._context;
    let { defs: defs2, instances } = context.getCurrentData().eventStore;
    let eventApis = [];
    for (let instanceId in instances) {
      let instance = instances[instanceId];
      let def = defs2[instance.defId];
      if (def.resourceIds.indexOf(thisResourceId) !== -1) {
        eventApis.push(new EventImpl(context, def, instance));
      }
    }
    return eventApis;
  }
  get id() {
    return getPublicId(this._resource.id);
  }
  get title() {
    return this._resource.title;
  }
  get eventConstraint() {
    return this._resource.ui.constraints[0] || null;
  }
  // TODO: better type
  get eventOverlap() {
    return this._resource.ui.overlap;
  }
  get eventAllow() {
    return this._resource.ui.allows[0] || null;
  }
  // TODO: better type
  get eventBackgroundColor() {
    return this._resource.ui.backgroundColor;
  }
  get eventBorderColor() {
    return this._resource.ui.borderColor;
  }
  get eventTextColor() {
    return this._resource.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get eventClassNames() {
    return this._resource.ui.classNames;
  }
  get extendedProps() {
    return this._resource.extendedProps;
  }
  toPlainObject(settings = {}) {
    let internal = this._resource;
    let { ui } = internal;
    let publicId = this.id;
    let res = {};
    if (publicId) {
      res.id = publicId;
    }
    if (internal.title) {
      res.title = internal.title;
    }
    if (settings.collapseEventColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.eventColor = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.eventBackgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.eventBorderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.eventTextColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.eventClassNames = ui.classNames;
    }
    if (Object.keys(internal.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, internal.extendedProps);
      } else {
        res.extendedProps = internal.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function buildResourceApis(resourceStore, context) {
  let resourceApis = [];
  for (let resourceId in resourceStore) {
    resourceApis.push(new ResourceApi(context, resourceStore[resourceId]));
  }
  return resourceApis;
}
var ResourceSplitter = class extends Splitter {
  getKeyInfo(props) {
    return Object.assign({ "": {} }, props.resourceStore);
  }
  getKeysForDateSpan(dateSpan) {
    return [dateSpan.resourceId || ""];
  }
  getKeysForEventDef(eventDef) {
    let resourceIds = eventDef.resourceIds;
    if (!resourceIds.length) {
      return [""];
    }
    return resourceIds;
  }
};
var DEFAULT_RESOURCE_ORDER = parseFieldSpecs("id,title");
function handleResourceStore(resourceStore, calendarData) {
  let { emitter } = calendarData;
  if (emitter.hasHandlers("resourcesSet")) {
    emitter.trigger("resourcesSet", buildResourceApis(resourceStore, calendarData));
  }
}
function refineRenderProps$1(input) {
  return {
    resource: new ResourceApi(input.context, input.resource)
  };
}
var ResourceLabelContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    const { props } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { options } = context;
      let renderProps = this.refineRenderProps({
        resource: props.resource,
        date: props.date,
        context
      });
      return y(ContentContainer, Object.assign({}, props, { elAttrs: Object.assign(Object.assign({}, props.elAttrs), { "data-resource-id": props.resource.id, "data-date": props.date ? formatDayString(props.date) : void 0 }), renderProps, generatorName: "resourceLabelContent", customGenerator: options.resourceLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.resourceLabelClassNames, didMount: options.resourceLabelDidMount, willUnmount: options.resourceLabelWillUnmount }));
    });
  }
};
function renderInnerContent(props) {
  return props.resource.title || props.resource.id;
}
function refineRenderProps(input) {
  return {
    resource: new ResourceApi(input.context, input.resource),
    date: input.date ? input.context.dateEnv.toDate(input.date) : null,
    view: input.context.viewApi
  };
}
var ResourceCell = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(ResourceLabelContainer, { elTag: "th", elClasses: ["fc-col-header-cell", "fc-resource"], elAttrs: {
      role: "columnheader",
      colSpan: props.colSpan
    }, resource: props.resource, date: props.date }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "span", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ] })
    ));
  }
};
var ResourceDayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.buildDateFormat = memoize(buildDateFormat);
  }
  render() {
    let { props, context } = this;
    let dateFormat = this.buildDateFormat(context.options.dayHeaderFormat, props.datesRepDistinctDays, props.dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
      if (props.dates.length === 1) {
        return this.renderResourceRow(props.resources, props.dates[0]);
      }
      if (context.options.datesAboveResources) {
        return this.renderDayAndResourceRows(props.dates, dateFormat, todayRange, props.resources);
      }
      return this.renderResourceAndDayRows(props.resources, props.dates, dateFormat, todayRange);
    });
  }
  renderResourceRow(resources, date) {
    let resourceCells = resources.map((resource) => y(ResourceCell, { key: resource.id, resource, colSpan: 1, date }));
    return this.buildTr(resourceCells, "resources");
  }
  renderDayAndResourceRows(dates, dateFormat, todayRange, resources) {
    let dateCells = [];
    let resourceCells = [];
    for (let date of dates) {
      dateCells.push(this.renderDateCell(date, dateFormat, todayRange, resources.length, null, true));
      for (let resource of resources) {
        resourceCells.push(y(ResourceCell, { key: resource.id + ":" + date.toISOString(), resource, colSpan: 1, date }));
      }
    }
    return y(
      _,
      null,
      this.buildTr(dateCells, "day"),
      this.buildTr(resourceCells, "resources")
    );
  }
  renderResourceAndDayRows(resources, dates, dateFormat, todayRange) {
    let resourceCells = [];
    let dateCells = [];
    for (let resource of resources) {
      resourceCells.push(y(ResourceCell, { key: resource.id, resource, colSpan: dates.length, isSticky: true }));
      for (let date of dates) {
        dateCells.push(this.renderDateCell(date, dateFormat, todayRange, 1, resource));
      }
    }
    return y(
      _,
      null,
      this.buildTr(resourceCells, "resources"),
      this.buildTr(dateCells, "day")
    );
  }
  // a cell with date text. might have a resource associated with it
  renderDateCell(date, dateFormat, todayRange, colSpan, resource, isSticky) {
    let { props } = this;
    let keyPostfix = resource ? `:${resource.id}` : "";
    let extraRenderProps = resource ? { resource: new ResourceApi(this.context, resource) } : {};
    let extraDataAttrs = resource ? { "data-resource-id": resource.id } : {};
    return props.datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString() + keyPostfix, date, dateProfile: props.dateProfile, todayRange, colCnt: props.dates.length * props.resources.length, dayHeaderFormat: dateFormat, colSpan, isSticky, extraRenderProps, extraDataAttrs }) : y(
      TableDowCell,
      { key: date.getUTCDay() + keyPostfix, dow: date.getUTCDay(), dayHeaderFormat: dateFormat, colSpan, isSticky, extraRenderProps, extraDataAttrs }
    );
  }
  buildTr(cells, key) {
    let { renderIntro } = this.props;
    if (!cells.length) {
      cells = [y("td", { key: 0 }, "Â ")];
    }
    return y(
      "tr",
      { key, role: "row" },
      renderIntro && renderIntro(key),
      cells
    );
  }
};
function buildDateFormat(dayHeaderFormat, datesRepDistinctDays, dayCnt) {
  return dayHeaderFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt);
}
var ResourceIndex = class {
  constructor(resources) {
    let indicesById = {};
    let ids = [];
    for (let i = 0; i < resources.length; i += 1) {
      let id = resources[i].id;
      ids.push(id);
      indicesById[id] = i;
    }
    this.ids = ids;
    this.indicesById = indicesById;
    this.length = resources.length;
  }
};
var AbstractResourceDayTableModel = class {
  constructor(dayTableModel, resources, context) {
    this.dayTableModel = dayTableModel;
    this.resources = resources;
    this.context = context;
    this.resourceIndex = new ResourceIndex(resources);
    this.rowCnt = dayTableModel.rowCnt;
    this.colCnt = dayTableModel.colCnt * resources.length;
    this.cells = this.buildCells();
  }
  buildCells() {
    let { rowCnt, dayTableModel, resources } = this;
    let rows = [];
    for (let row = 0; row < rowCnt; row += 1) {
      let rowCells = [];
      for (let dateCol = 0; dateCol < dayTableModel.colCnt; dateCol += 1) {
        for (let resourceCol = 0; resourceCol < resources.length; resourceCol += 1) {
          let resource = resources[resourceCol];
          let extraRenderProps = { resource: new ResourceApi(this.context, resource) };
          let extraDataAttrs = { "data-resource-id": resource.id };
          let extraClassNames = ["fc-resource"];
          let extraDateSpan = { resourceId: resource.id };
          let date = dayTableModel.cells[row][dateCol].date;
          rowCells[this.computeCol(dateCol, resourceCol)] = {
            key: resource.id + ":" + date.toISOString(),
            date,
            extraRenderProps,
            extraDataAttrs,
            extraClassNames,
            extraDateSpan
          };
        }
      }
      rows.push(rowCells);
    }
    return rows;
  }
};
var ResourceDayTableModel = class extends AbstractResourceDayTableModel {
  computeCol(dateI, resourceI) {
    return resourceI * this.dayTableModel.colCnt + dateI;
  }
  /*
  all date ranges are intact
  */
  computeColRanges(dateStartI, dateEndI, resourceI) {
    return [
      {
        firstCol: this.computeCol(dateStartI, resourceI),
        lastCol: this.computeCol(dateEndI, resourceI),
        isStart: true,
        isEnd: true
      }
    ];
  }
};
var DayResourceTableModel = class extends AbstractResourceDayTableModel {
  computeCol(dateI, resourceI) {
    return dateI * this.resources.length + resourceI;
  }
  /*
  every single day is broken up
  */
  computeColRanges(dateStartI, dateEndI, resourceI) {
    let segs = [];
    for (let i = dateStartI; i <= dateEndI; i += 1) {
      let col = this.computeCol(i, resourceI);
      segs.push({
        firstCol: col,
        lastCol: col,
        isStart: i === dateStartI,
        isEnd: i === dateEndI
      });
    }
    return segs;
  }
};
var NO_SEGS = [];
var VResourceJoiner = class {
  constructor() {
    this.joinDateSelection = memoize(this.joinSegs);
    this.joinBusinessHours = memoize(this.joinSegs);
    this.joinFgEvents = memoize(this.joinSegs);
    this.joinBgEvents = memoize(this.joinSegs);
    this.joinEventDrags = memoize(this.joinInteractions);
    this.joinEventResizes = memoize(this.joinInteractions);
  }
  /*
  propSets also has a '' key for things with no resource
  */
  joinProps(propSets, resourceDayTable) {
    let dateSelectionSets = [];
    let businessHoursSets = [];
    let fgEventSets = [];
    let bgEventSets = [];
    let eventDrags = [];
    let eventResizes = [];
    let eventSelection = "";
    let keys = resourceDayTable.resourceIndex.ids.concat([""]);
    for (let key of keys) {
      let props = propSets[key];
      dateSelectionSets.push(props.dateSelectionSegs);
      businessHoursSets.push(key ? props.businessHourSegs : NO_SEGS);
      fgEventSets.push(key ? props.fgEventSegs : NO_SEGS);
      bgEventSets.push(props.bgEventSegs);
      eventDrags.push(props.eventDrag);
      eventResizes.push(props.eventResize);
      eventSelection = eventSelection || props.eventSelection;
    }
    return {
      dateSelectionSegs: this.joinDateSelection(resourceDayTable, ...dateSelectionSets),
      businessHourSegs: this.joinBusinessHours(resourceDayTable, ...businessHoursSets),
      fgEventSegs: this.joinFgEvents(resourceDayTable, ...fgEventSets),
      bgEventSegs: this.joinBgEvents(resourceDayTable, ...bgEventSets),
      eventDrag: this.joinEventDrags(resourceDayTable, ...eventDrags),
      eventResize: this.joinEventResizes(resourceDayTable, ...eventResizes),
      eventSelection
    };
  }
  joinSegs(resourceDayTable, ...segGroups) {
    let resourceCnt = resourceDayTable.resources.length;
    let transformedSegs = [];
    for (let i = 0; i < resourceCnt; i += 1) {
      for (let seg of segGroups[i]) {
        transformedSegs.push(...this.transformSeg(seg, resourceDayTable, i));
      }
      for (let seg of segGroups[resourceCnt]) {
        transformedSegs.push(...this.transformSeg(seg, resourceDayTable, i));
      }
    }
    return transformedSegs;
  }
  /*
  for expanding non-resource segs to all resources.
  only for public use.
  no memoizing.
  */
  expandSegs(resourceDayTable, segs) {
    let resourceCnt = resourceDayTable.resources.length;
    let transformedSegs = [];
    for (let i = 0; i < resourceCnt; i += 1) {
      for (let seg of segs) {
        transformedSegs.push(...this.transformSeg(seg, resourceDayTable, i));
      }
    }
    return transformedSegs;
  }
  joinInteractions(resourceDayTable, ...interactions) {
    let resourceCnt = resourceDayTable.resources.length;
    let affectedInstances = {};
    let transformedSegs = [];
    let anyInteractions = false;
    let isEvent = false;
    for (let i = 0; i < resourceCnt; i += 1) {
      let interaction = interactions[i];
      if (interaction) {
        anyInteractions = true;
        for (let seg of interaction.segs) {
          transformedSegs.push(...this.transformSeg(seg, resourceDayTable, i));
        }
        Object.assign(affectedInstances, interaction.affectedInstances);
        isEvent = isEvent || interaction.isEvent;
      }
      if (interactions[resourceCnt]) {
        for (let seg of interactions[resourceCnt].segs) {
          transformedSegs.push(...this.transformSeg(seg, resourceDayTable, i));
        }
      }
    }
    if (anyInteractions) {
      return {
        affectedInstances,
        segs: transformedSegs,
        isEvent
      };
    }
    return null;
  }
};
var VResourceSplitter = class extends Splitter {
  getKeyInfo(props) {
    let { resourceDayTableModel } = props;
    let hash = mapHash(resourceDayTableModel.resourceIndex.indicesById, (i) => resourceDayTableModel.resources[i]);
    hash[""] = {};
    return hash;
  }
  getKeysForDateSpan(dateSpan) {
    return [dateSpan.resourceId || ""];
  }
  getKeysForEventDef(eventDef) {
    let resourceIds = eventDef.resourceIds;
    if (!resourceIds.length) {
      return [""];
    }
    return resourceIds;
  }
};
function flattenResources(resourceStore, orderSpecs) {
  return buildRowNodes(resourceStore, [], orderSpecs, false, {}, true).map((node) => node.resource);
}
function buildRowNodes(resourceStore, groupSpecs, orderSpecs, isVGrouping, expansions, expansionDefault) {
  let complexNodes = buildHierarchy(resourceStore, isVGrouping ? -1 : 1, groupSpecs, orderSpecs);
  let flatNodes = [];
  flattenNodes(complexNodes, flatNodes, isVGrouping, [], 0, expansions, expansionDefault);
  return flatNodes;
}
function flattenNodes(complexNodes, res, isVGrouping, rowSpans, depth, expansions, expansionDefault) {
  for (let i = 0; i < complexNodes.length; i += 1) {
    let complexNode = complexNodes[i];
    let group = complexNode.group;
    if (group) {
      if (isVGrouping) {
        let firstRowIndex = res.length;
        let rowSpanIndex = rowSpans.length;
        flattenNodes(complexNode.children, res, isVGrouping, rowSpans.concat(0), depth, expansions, expansionDefault);
        if (firstRowIndex < res.length) {
          let firstRow = res[firstRowIndex];
          let firstRowSpans = firstRow.rowSpans = firstRow.rowSpans.slice();
          firstRowSpans[rowSpanIndex] = res.length - firstRowIndex;
        }
      } else {
        let id = group.spec.field + ":" + group.value;
        let isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;
        res.push({ id, group, isExpanded });
        if (isExpanded) {
          flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);
        }
      }
    } else if (complexNode.resource) {
      let id = complexNode.resource.id;
      let isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;
      res.push({
        id,
        rowSpans,
        depth,
        isExpanded,
        hasChildren: Boolean(complexNode.children.length),
        resource: complexNode.resource,
        resourceFields: complexNode.resourceFields
      });
      if (isExpanded) {
        flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);
      }
    }
  }
}
function buildHierarchy(resourceStore, maxDepth, groupSpecs, orderSpecs) {
  let resourceNodes = buildResourceNodes(resourceStore, orderSpecs);
  let builtNodes = [];
  for (let resourceId in resourceNodes) {
    let resourceNode = resourceNodes[resourceId];
    if (!resourceNode.resource.parentId) {
      insertResourceNode(resourceNode, builtNodes, groupSpecs, 0, maxDepth, orderSpecs);
    }
  }
  return builtNodes;
}
function buildResourceNodes(resourceStore, orderSpecs) {
  let nodeHash = {};
  for (let resourceId in resourceStore) {
    let resource = resourceStore[resourceId];
    nodeHash[resourceId] = {
      resource,
      resourceFields: buildResourceFields(resource),
      children: []
    };
  }
  for (let resourceId in resourceStore) {
    let resource = resourceStore[resourceId];
    if (resource.parentId) {
      let parentNode = nodeHash[resource.parentId];
      if (parentNode) {
        insertResourceNodeInSiblings(nodeHash[resourceId], parentNode.children, orderSpecs);
      }
    }
  }
  return nodeHash;
}
function insertResourceNode(resourceNode, nodes, groupSpecs, depth, maxDepth, orderSpecs) {
  if (groupSpecs.length && (maxDepth === -1 || depth <= maxDepth)) {
    let groupNode = ensureGroupNodes(resourceNode, nodes, groupSpecs[0]);
    insertResourceNode(resourceNode, groupNode.children, groupSpecs.slice(1), depth + 1, maxDepth, orderSpecs);
  } else {
    insertResourceNodeInSiblings(resourceNode, nodes, orderSpecs);
  }
}
function ensureGroupNodes(resourceNode, nodes, groupSpec) {
  let groupValue = resourceNode.resourceFields[groupSpec.field];
  let groupNode;
  let newGroupIndex;
  if (groupSpec.order) {
    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex += 1) {
      let node = nodes[newGroupIndex];
      if (node.group) {
        let cmp = flexibleCompare(groupValue, node.group.value) * groupSpec.order;
        if (cmp === 0) {
          groupNode = node;
          break;
        } else if (cmp < 0) {
          break;
        }
      }
    }
  } else {
    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex += 1) {
      let node = nodes[newGroupIndex];
      if (node.group && groupValue === node.group.value) {
        groupNode = node;
        break;
      }
    }
  }
  if (!groupNode) {
    groupNode = {
      group: {
        value: groupValue,
        spec: groupSpec
      },
      children: []
    };
    nodes.splice(newGroupIndex, 0, groupNode);
  }
  return groupNode;
}
function insertResourceNodeInSiblings(resourceNode, siblings, orderSpecs) {
  let i;
  for (i = 0; i < siblings.length; i += 1) {
    let cmp = compareByFieldSpecs(siblings[i].resourceFields, resourceNode.resourceFields, orderSpecs);
    if (cmp > 0) {
      break;
    }
  }
  siblings.splice(i, 0, resourceNode);
}
function buildResourceFields(resource) {
  let obj = Object.assign(Object.assign(Object.assign({}, resource.extendedProps), resource.ui), resource);
  delete obj.ui;
  delete obj.extendedProps;
  return obj;
}
function isGroupsEqual(group0, group1) {
  return group0.spec === group1.spec && group0.value === group1.value;
}

// node_modules/@fullcalendar/resource/index.js
function massageEventDragMutation(eventMutation, hit0, hit1) {
  let resource0 = hit0.dateSpan.resourceId;
  let resource1 = hit1.dateSpan.resourceId;
  if (resource0 && resource1 && resource0 !== resource1) {
    eventMutation.resourceMutation = {
      matchResourceId: resource0,
      setResourceId: resource1
    };
  }
}
function applyEventDefMutation(eventDef, mutation, context) {
  let resourceMutation = mutation.resourceMutation;
  if (resourceMutation && computeResourceEditable(eventDef, context)) {
    let index3 = eventDef.resourceIds.indexOf(resourceMutation.matchResourceId);
    if (index3 !== -1) {
      let resourceIds = eventDef.resourceIds.slice();
      resourceIds.splice(index3, 1);
      if (resourceIds.indexOf(resourceMutation.setResourceId) === -1) {
        resourceIds.push(resourceMutation.setResourceId);
      }
      eventDef.resourceIds = resourceIds;
    }
  }
}
function computeResourceEditable(eventDef, context) {
  let { resourceEditable } = eventDef;
  if (resourceEditable == null) {
    let source = eventDef.sourceId && context.getCurrentData().eventSources[eventDef.sourceId];
    if (source) {
      resourceEditable = source.extendedProps.resourceEditable;
    }
    if (resourceEditable == null) {
      resourceEditable = context.options.eventResourceEditable;
      if (resourceEditable == null) {
        resourceEditable = context.options.editable;
      }
    }
  }
  return resourceEditable;
}
function transformEventDrop(mutation, context) {
  let { resourceMutation } = mutation;
  if (resourceMutation) {
    let { calendarApi } = context;
    return {
      oldResource: calendarApi.getResourceById(resourceMutation.matchResourceId),
      newResource: calendarApi.getResourceById(resourceMutation.setResourceId)
    };
  }
  return {
    oldResource: null,
    newResource: null
  };
}
var ResourceDataAdder = class {
  constructor() {
    this.filterResources = memoize(filterResources);
  }
  transform(viewProps, calendarProps) {
    if (calendarProps.viewSpec.optionDefaults.needsResourceData) {
      return {
        resourceStore: this.filterResources(calendarProps.resourceStore, calendarProps.options.filterResourcesWithEvents, calendarProps.eventStore, calendarProps.dateProfile.activeRange),
        resourceEntityExpansions: calendarProps.resourceEntityExpansions
      };
    }
    return null;
  }
};
function filterResources(resourceStore, doFilterResourcesWithEvents, eventStore, activeRange) {
  if (doFilterResourcesWithEvents) {
    let instancesInRange = filterEventInstancesInRange(eventStore.instances, activeRange);
    let hasEvents = computeHasEvents(instancesInRange, eventStore.defs);
    Object.assign(hasEvents, computeAncestorHasEvents(hasEvents, resourceStore));
    return filterHash(resourceStore, (resource, resourceId) => hasEvents[resourceId]);
  }
  return resourceStore;
}
function filterEventInstancesInRange(eventInstances, activeRange) {
  return filterHash(eventInstances, (eventInstance) => rangesIntersect(eventInstance.range, activeRange));
}
function computeHasEvents(eventInstances, eventDefs) {
  let hasEvents = {};
  for (let instanceId in eventInstances) {
    let instance = eventInstances[instanceId];
    for (let resourceId of eventDefs[instance.defId].resourceIds) {
      hasEvents[resourceId] = true;
    }
  }
  return hasEvents;
}
function computeAncestorHasEvents(hasEvents, resourceStore) {
  let res = {};
  for (let resourceId in hasEvents) {
    let resource;
    while (resource = resourceStore[resourceId]) {
      resourceId = resource.parentId;
      if (resourceId) {
        res[resourceId] = true;
      } else {
        break;
      }
    }
  }
  return res;
}
function transformIsDraggable(val, eventDef, eventUi, context) {
  if (!val) {
    let state = context.getCurrentData();
    let viewSpec = state.viewSpecs[state.currentViewType];
    if (viewSpec.optionDefaults.needsResourceData) {
      if (computeResourceEditable(eventDef, context)) {
        return true;
      }
    }
  }
  return val;
}
var ResourceEventConfigAdder = class {
  constructor() {
    this.buildResourceEventUis = memoize(buildResourceEventUis, isPropsEqual);
    this.injectResourceEventUis = memoize(injectResourceEventUis);
  }
  transform(viewProps, calendarProps) {
    if (!calendarProps.viewSpec.optionDefaults.needsResourceData) {
      return {
        eventUiBases: this.injectResourceEventUis(viewProps.eventUiBases, viewProps.eventStore.defs, this.buildResourceEventUis(calendarProps.resourceStore))
      };
    }
    return null;
  }
};
function buildResourceEventUis(resourceStore) {
  return mapHash(resourceStore, (resource) => resource.ui);
}
function injectResourceEventUis(eventUiBases, eventDefs, resourceEventUis) {
  return mapHash(eventUiBases, (eventUi, defId) => {
    if (defId) {
      return injectResourceEventUi(eventUi, eventDefs[defId], resourceEventUis);
    }
    return eventUi;
  });
}
function injectResourceEventUi(origEventUi, eventDef, resourceEventUis) {
  let parts = [];
  for (let resourceId of eventDef.resourceIds) {
    if (resourceEventUis[resourceId]) {
      parts.unshift(resourceEventUis[resourceId]);
    }
  }
  parts.unshift(origEventUi);
  return combineEventUis(parts);
}
var defs = [];
function registerResourceSourceDef(def) {
  defs.push(def);
}
function getResourceSourceDef(id) {
  return defs[id];
}
function getResourceSourceDefs() {
  return defs;
}
var RESOURCE_SOURCE_REFINERS = {
  id: String,
  // for array. TODO: move to resource-array
  resources: identity,
  // for json feed. TODO: move to resource-json-feed
  url: String,
  method: String,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  extraParams: identity
};
function parseResourceSource(input) {
  let inputObj;
  if (typeof input === "string") {
    inputObj = { url: input };
  } else if (typeof input === "function" || Array.isArray(input)) {
    inputObj = { resources: input };
  } else if (typeof input === "object" && input) {
    inputObj = input;
  }
  if (inputObj) {
    let { refined, extra } = refineProps(inputObj, RESOURCE_SOURCE_REFINERS);
    warnUnknownProps(extra);
    let metaRes = buildResourceSourceMeta(refined);
    if (metaRes) {
      return {
        _raw: input,
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        publicId: refined.id || "",
        isFetching: false,
        latestFetchId: "",
        fetchRange: null
      };
    }
  }
  return null;
}
function buildResourceSourceMeta(refined) {
  let defs2 = getResourceSourceDefs();
  for (let i = defs2.length - 1; i >= 0; i -= 1) {
    let def = defs2[i];
    let meta = def.parseMeta(refined);
    if (meta) {
      return { meta, sourceDefId: i };
    }
  }
  return null;
}
function warnUnknownProps(props) {
  for (let propName in props) {
    console.warn(`Unknown resource prop '${propName}'`);
  }
}
function reduceResourceSource(source, action, context) {
  let { options, dateProfile } = context;
  if (!source || !action) {
    return createSource(options.initialResources || options.resources, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
  }
  switch (action.type) {
    case "RESET_RESOURCE_SOURCE":
      return createSource(action.resourceSourceInput, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      return handleRangeChange(source, dateProfile.activeRange, options.refetchResourcesOnNavigate, context);
    case "RECEIVE_RESOURCES":
    case "RECEIVE_RESOURCE_ERROR":
      return receiveResponse(source, action.fetchId, action.fetchRange);
    case "REFETCH_RESOURCES":
      return fetchSource(source, dateProfile.activeRange, context);
    default:
      return source;
  }
}
function createSource(input, activeRange, refetchResourcesOnNavigate, context) {
  if (input) {
    let source = parseResourceSource(input);
    source = fetchSource(source, refetchResourcesOnNavigate ? activeRange : null, context);
    return source;
  }
  return null;
}
function handleRangeChange(source, activeRange, refetchResourcesOnNavigate, context) {
  if (refetchResourcesOnNavigate && !doesSourceIgnoreRange(source) && (!source.fetchRange || !rangesEqual(source.fetchRange, activeRange))) {
    return fetchSource(source, activeRange, context);
  }
  return source;
}
function doesSourceIgnoreRange(source) {
  return Boolean(getResourceSourceDef(source.sourceDefId).ignoreRange);
}
function fetchSource(source, fetchRange, context) {
  let sourceDef = getResourceSourceDef(source.sourceDefId);
  let fetchId = guid();
  sourceDef.fetch({
    resourceSource: source,
    range: fetchRange,
    context
  }, (res) => {
    context.dispatch({
      type: "RECEIVE_RESOURCES",
      fetchId,
      fetchRange,
      rawResources: res.rawResources
    });
  }, (error) => {
    context.dispatch({
      type: "RECEIVE_RESOURCE_ERROR",
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, source), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(source, fetchId, fetchRange) {
  if (fetchId === source.latestFetchId) {
    return Object.assign(Object.assign({}, source), { isFetching: false, fetchRange });
  }
  return source;
}
function reduceResourceStore(store, action, source, context) {
  if (!store || !action) {
    return {};
  }
  switch (action.type) {
    case "RECEIVE_RESOURCES":
      return receiveRawResources(store, action.rawResources, action.fetchId, source, context);
    case "ADD_RESOURCE":
      return addResource(store, action.resourceHash);
    case "REMOVE_RESOURCE":
      return removeResource(store, action.resourceId);
    case "SET_RESOURCE_PROP":
      return setResourceProp(store, action.resourceId, action.propName, action.propValue);
    case "SET_RESOURCE_EXTENDED_PROP":
      return setResourceExtendedProp(store, action.resourceId, action.propName, action.propValue);
    default:
      return store;
  }
}
function receiveRawResources(existingStore, inputs, fetchId, source, context) {
  if (source.latestFetchId === fetchId) {
    let nextStore = {};
    for (let input of inputs) {
      parseResource(input, "", nextStore, context);
    }
    return nextStore;
  }
  return existingStore;
}
function addResource(existingStore, additions) {
  return Object.assign(Object.assign({}, existingStore), additions);
}
function removeResource(existingStore, resourceId) {
  let newStore = Object.assign({}, existingStore);
  delete newStore[resourceId];
  for (let childResourceId in newStore) {
    if (newStore[childResourceId].parentId === resourceId) {
      newStore[childResourceId] = Object.assign(Object.assign({}, newStore[childResourceId]), { parentId: "" });
    }
  }
  return newStore;
}
function setResourceProp(existingStore, resourceId, name, value) {
  let existingResource = existingStore[resourceId];
  if (existingResource) {
    return Object.assign(Object.assign({}, existingStore), { [resourceId]: Object.assign(Object.assign({}, existingResource), { [name]: value }) });
  }
  return existingStore;
}
function setResourceExtendedProp(existingStore, resourceId, name, value) {
  let existingResource = existingStore[resourceId];
  if (existingResource) {
    return Object.assign(Object.assign({}, existingStore), { [resourceId]: Object.assign(Object.assign({}, existingResource), { extendedProps: Object.assign(Object.assign({}, existingResource.extendedProps), { [name]: value }) }) });
  }
  return existingStore;
}
function reduceResourceEntityExpansions(expansions, action) {
  if (!expansions || !action) {
    return {};
  }
  switch (action.type) {
    case "SET_RESOURCE_ENTITY_EXPANDED":
      return Object.assign(Object.assign({}, expansions), { [action.id]: action.isExpanded });
    default:
      return expansions;
  }
}
function reduceResources(state, action, context) {
  let resourceSource = reduceResourceSource(state && state.resourceSource, action, context);
  let resourceStore = reduceResourceStore(state && state.resourceStore, action, resourceSource, context);
  let resourceEntityExpansions = reduceResourceEntityExpansions(state && state.resourceEntityExpansions, action);
  return {
    resourceSource,
    resourceStore,
    resourceEntityExpansions
  };
}
var EVENT_REFINERS = {
  resourceId: String,
  resourceIds: identity,
  resourceEditable: Boolean
};
function generateEventDefResourceMembers(refined) {
  return {
    resourceIds: ensureStringArray(refined.resourceIds).concat(refined.resourceId ? [refined.resourceId] : []),
    resourceEditable: refined.resourceEditable
  };
}
function ensureStringArray(items) {
  return (items || []).map((item) => String(item));
}
function transformDateSelectionJoin(hit0, hit1) {
  let resourceId0 = hit0.dateSpan.resourceId;
  let resourceId1 = hit1.dateSpan.resourceId;
  if (resourceId0 && resourceId1) {
    return { resourceId: resourceId0 };
  }
  return null;
}
CalendarImpl.prototype.addResource = function(input, scrollTo = true) {
  let currentState = this.getCurrentData();
  let resourceHash;
  let resource;
  if (input instanceof ResourceApi) {
    resource = input._resource;
    resourceHash = { [resource.id]: resource };
  } else {
    resourceHash = {};
    resource = parseResource(input, "", resourceHash, currentState);
  }
  this.dispatch({
    type: "ADD_RESOURCE",
    resourceHash
  });
  if (scrollTo) {
    this.trigger("_scrollRequest", { resourceId: resource.id });
  }
  let resourceApi = new ResourceApi(currentState, resource);
  currentState.emitter.trigger("resourceAdd", {
    resource: resourceApi,
    revert: () => {
      this.dispatch({
        type: "REMOVE_RESOURCE",
        resourceId: resource.id
      });
    }
  });
  return resourceApi;
};
CalendarImpl.prototype.getResourceById = function(id) {
  id = String(id);
  let currentState = this.getCurrentData();
  if (currentState.resourceStore) {
    let rawResource = currentState.resourceStore[id];
    if (rawResource) {
      return new ResourceApi(currentState, rawResource);
    }
  }
  return null;
};
CalendarImpl.prototype.getResources = function() {
  let currentState = this.getCurrentData();
  let { resourceStore } = currentState;
  let resourceApis = [];
  if (resourceStore) {
    for (let resourceId in resourceStore) {
      resourceApis.push(new ResourceApi(currentState, resourceStore[resourceId]));
    }
  }
  return resourceApis;
};
CalendarImpl.prototype.getTopLevelResources = function() {
  let currentState = this.getCurrentData();
  let { resourceStore } = currentState;
  let resourceApis = [];
  if (resourceStore) {
    for (let resourceId in resourceStore) {
      if (!resourceStore[resourceId].parentId) {
        resourceApis.push(new ResourceApi(currentState, resourceStore[resourceId]));
      }
    }
  }
  return resourceApis;
};
CalendarImpl.prototype.refetchResources = function() {
  this.dispatch({
    type: "REFETCH_RESOURCES"
  });
};
function transformDatePoint(dateSpan, context) {
  return dateSpan.resourceId ? { resource: context.calendarApi.getResourceById(dateSpan.resourceId) } : {};
}
function transformDateSpan(dateSpan, context) {
  return dateSpan.resourceId ? { resource: context.calendarApi.getResourceById(dateSpan.resourceId) } : {};
}
function isPropsValidWithResources(combinedProps, context) {
  let splitter = new ResourceSplitter();
  let sets = splitter.splitProps(Object.assign(Object.assign({}, combinedProps), { resourceStore: context.getCurrentData().resourceStore }));
  for (let resourceId in sets) {
    let props = sets[resourceId];
    if (resourceId && sets[""]) {
      props = Object.assign(Object.assign({}, props), { eventStore: mergeEventStores(sets[""].eventStore, props.eventStore), eventUiBases: Object.assign(Object.assign({}, sets[""].eventUiBases), props.eventUiBases) });
    }
    if (!isPropsValid(props, context, { resourceId }, filterConfig.bind(null, resourceId))) {
      return false;
    }
  }
  return true;
}
function filterConfig(resourceId, config2) {
  return Object.assign(Object.assign({}, config2), { constraints: filterConstraints(resourceId, config2.constraints) });
}
function filterConstraints(resourceId, constraints) {
  return constraints.map((constraint) => {
    let defs2 = constraint.defs;
    if (defs2) {
      for (let defId in defs2) {
        let resourceIds = defs2[defId].resourceIds;
        if (resourceIds.length && resourceIds.indexOf(resourceId) === -1) {
          return false;
        }
      }
    }
    return constraint;
  });
}
function transformExternalDef(dateSpan) {
  return dateSpan.resourceId ? { resourceId: dateSpan.resourceId } : {};
}
var optionChangeHandlers = {
  resources: handleResources
};
function handleResources(newSourceInput, context) {
  let oldSourceInput = context.getCurrentData().resourceSource._raw;
  if (oldSourceInput !== newSourceInput) {
    context.dispatch({
      type: "RESET_RESOURCE_SOURCE",
      resourceSourceInput: newSourceInput
    });
  }
}
var OPTION_REFINERS2 = {
  initialResources: identity,
  resources: identity,
  eventResourceEditable: Boolean,
  refetchResourcesOnNavigate: Boolean,
  resourceOrder: parseFieldSpecs,
  filterResourcesWithEvents: Boolean,
  resourceGroupField: String,
  resourceAreaWidth: identity,
  resourceAreaColumns: identity,
  resourcesInitiallyExpanded: Boolean,
  datesAboveResources: Boolean,
  needsResourceData: Boolean,
  resourceAreaHeaderClassNames: identity,
  resourceAreaHeaderContent: identity,
  resourceAreaHeaderDidMount: identity,
  resourceAreaHeaderWillUnmount: identity,
  resourceGroupLabelClassNames: identity,
  resourceGroupLabelContent: identity,
  resourceGroupLabelDidMount: identity,
  resourceGroupLabelWillUnmount: identity,
  resourceLabelClassNames: identity,
  resourceLabelContent: identity,
  resourceLabelDidMount: identity,
  resourceLabelWillUnmount: identity,
  resourceLaneClassNames: identity,
  resourceLaneContent: identity,
  resourceLaneDidMount: identity,
  resourceLaneWillUnmount: identity,
  resourceGroupLaneClassNames: identity,
  resourceGroupLaneContent: identity,
  resourceGroupLaneDidMount: identity,
  resourceGroupLaneWillUnmount: identity
};
var LISTENER_REFINERS = {
  resourcesSet: identity,
  resourceAdd: identity,
  resourceChange: identity,
  resourceRemove: identity
};
EventImpl.prototype.getResources = function() {
  let { calendarApi } = this._context;
  return this._def.resourceIds.map((resourceId) => calendarApi.getResourceById(resourceId));
};
EventImpl.prototype.setResources = function(resources) {
  let resourceIds = [];
  for (let resource of resources) {
    let resourceId = null;
    if (typeof resource === "string") {
      resourceId = resource;
    } else if (typeof resource === "number") {
      resourceId = String(resource);
    } else if (resource instanceof ResourceApi) {
      resourceId = resource.id;
    } else {
      console.warn("unknown resource type: " + resource);
    }
    if (resourceId) {
      resourceIds.push(resourceId);
    }
  }
  this.mutate({
    standardProps: {
      resourceIds
    }
  });
};
registerResourceSourceDef({
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.resources)) {
      return refined.resources;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawResources: arg.resourceSource.meta
    });
  }
});
registerResourceSourceDef({
  parseMeta(refined) {
    if (typeof refined.resources === "function") {
      return refined.resources;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const dateEnv = arg.context.dateEnv;
    const func = arg.resourceSource.meta;
    const publicArg = arg.range ? {
      start: dateEnv.toDate(arg.range.start),
      end: dateEnv.toDate(arg.range.end),
      startStr: dateEnv.formatIso(arg.range.start),
      endStr: dateEnv.formatIso(arg.range.end),
      timeZone: dateEnv.timeZone
    } : {};
    unpromisify(func.bind(null, publicArg), (rawResources) => successCallback({ rawResources }), errorCallback);
  }
});
registerResourceSourceDef({
  parseMeta(refined) {
    if (refined.url) {
      return {
        url: refined.url,
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const meta = arg.resourceSource.meta;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawResources, response]) => {
      successCallback({ rawResources, response });
    }, errorCallback);
  }
});
function buildRequestParams(meta, range, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  if (range) {
    startParam = meta.startParam;
    if (startParam == null) {
      startParam = options.startParam;
    }
    endParam = meta.endParam;
    if (endParam == null) {
      endParam = options.endParam;
    }
    timeZoneParam = meta.timeZoneParam;
    if (timeZoneParam == null) {
      timeZoneParam = options.timeZoneParam;
    }
    params[startParam] = dateEnv.formatIso(range.start);
    params[endParam] = dateEnv.formatIso(range.end);
    if (dateEnv.timeZone !== "local") {
      params[timeZoneParam] = dateEnv.timeZone;
    }
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  return params;
}
var index2 = createPlugin({
  name: "@fullcalendar/resource",
  premiumReleaseDate: "2025-04-02",
  deps: [index],
  reducers: [reduceResources],
  isLoadingFuncs: [
    (state) => state.resourceSource && state.resourceSource.isFetching
  ],
  eventRefiners: EVENT_REFINERS,
  eventDefMemberAdders: [generateEventDefResourceMembers],
  isDraggableTransformers: [transformIsDraggable],
  eventDragMutationMassagers: [massageEventDragMutation],
  eventDefMutationAppliers: [applyEventDefMutation],
  dateSelectionTransformers: [transformDateSelectionJoin],
  datePointTransforms: [transformDatePoint],
  dateSpanTransforms: [transformDateSpan],
  viewPropsTransformers: [ResourceDataAdder, ResourceEventConfigAdder],
  isPropsValid: isPropsValidWithResources,
  externalDefTransforms: [transformExternalDef],
  eventDropTransformers: [transformEventDrop],
  optionChangeHandlers,
  optionRefiners: OPTION_REFINERS2,
  listenerRefiners: LISTENER_REFINERS,
  propSetHandlers: { resourceStore: handleResourceStore }
});

export {
  index,
  getPublicId,
  ResourceApi,
  ResourceSplitter,
  DEFAULT_RESOURCE_ORDER,
  refineRenderProps$1,
  ResourceDayHeader,
  ResourceDayTableModel,
  DayResourceTableModel,
  VResourceJoiner,
  VResourceSplitter,
  flattenResources,
  buildRowNodes,
  buildResourceFields,
  isGroupsEqual,
  index2
};
//# sourceMappingURL=chunk-V6OEUF75.js.map
